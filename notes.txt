########################################
########## HELPFUL COMMANDS
########################################

show dbs                     	show database names
show collections             	show collections in current database
show users                   	show users in current database
db.getName();					Get current database name
use <db_name>					Set current database
db.dropDatabase();				Delete/drop current database
show collections				Show the collections contained in the current database

mvn clean compile exec:java -Dexec.mainClass=com.mongdb.App

########################################
########## WEEK 2 - CRUD

##### Creating documents

mongorestore dump
insertOne();
insertMany();
UPDATE COMMANDS is known as "upserts".

##### The _id Field

All collections have a unique primary index on the _id field by default.

			Date    MAC		PID		Counter
ObjectId: _ _ _ _ | _ _ _ | _ _ | _ _ _
12-Byte Hex String

Date - Current time stamp
MAC - The MAC address for the machine on which the MongoDB server is running.
PID - Process ID.
Counter - A standard counter to make sure that the ObjectId is indeed unique.

Note that the "Date" label that refers to the first four bytes does in fact reference a UTC datetime with a precision of seconds (not days). When talking about BSON, this is distinct from a timestamp, which is a special internal data type used in MongoDB replication and sharding.

##### Reading documents

db.movieDetails.find({ rated: "PG-13" }).pretty();
db.movieDetails.find({ rated: "PG-13" }).count();
db.movieDetails.find({ rated: "PG-13", year: 2009 }).count();
db.movieDetails.find({ "tomato.meter": 100 }).count();
db.movieDetails.find({ "tomato.meter": 99 }).pretty();

// For this particular case the order of the elements matters
// So the writers array must have only two elements following the order which each one was inserted
db.movieDetails.find({ "writers": ["Ethan Coen", "Joel Coen"] }).count();

// In this very case it will match all documents which have the actor "Jeff Bridges", thus this is not an exact match like the previous one
db.movieDetails.find({ "actors": "Jeff Bridges" }).pretty();

// All documents which have "Jeff Bridges" as the first element in actors array
db.movieDetails.find({ "actors.0": "Jeff Bridges" }).pretty();

// The find method returns a cursor. If you do the command below without assigning a variable to it, the cursor will automatically iterate up to 20 times.
db.movieDetails.find({ rated: "PG" }).pretty();

// Cursors

var c = db.movieDetails.find();
var doc = function() { return c.hasNext() ? c.next() : null; }
c.objsLeftInBatch(); // 101 documents in the initial batch
doc() // to iterate using the cursor
c.objsLeftInBatch(); // if will do the command again it will return 100 documents

// Projectinos

// It will include only the attribute title and exclude _id
db.movieDetails.find({ rated: "PG" }, { title: 1, _id: 0 } ).pretty();

// It will include all fields except for the ones explicity excluded below
db.movieDetails.find( { rated: "PG" }, { writers: 0, actors: 0, _id: 0 } ).pretty();

##### Comparison operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-comparison/

// All movies that have a runtime greater than 90
db.movieDetails.find({ runtime: { $gt: 90 } }).pretty();
db.movieDetails.find({ runtime: { $gt: 90 } }).count();
db.movieDetails.find({ runtime: { $gt: 90 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
// Greater than or equal to 90 and less than or equal to 120. It means: (runtime >= 90 && runtime <= 120)
db.movieDetails.find({ runtime: { $gte: 90, $lte: 120 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ "tomato.meter": { $gte: 95 }, runtime: { $gt: 180 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ rated: { $ne: "UNRATED" } }, { title: 1, runtime: 1, _id: 0 }).count();
// Return all the documents where the value of rated is G or PG
db.movieDetails.find({ rated: { $in: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();
// The reverse statement of the prepostion above
db.movieDetails.find({ rated: { $nin: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();

##### Element operators

// It verifies if there are documents which have tomate.meter field
db.movieDetails.find({ "tomato.meter": { $exists: true } }).count();

db.moviesScratch.find({ _id: { $type: "string" } }).pretty();
// We can count how many documents are stored with _id as String and so on
db.moviesScratch.find({ _id: { $type: "string" } }).count();
db.moviesScratch.find({ _id: { $type: "objectId" } }).pretty();

##### Logical operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-logical/

// $or takes an array as an argument
db.movieDetails.find({ $or : [ { "tomato.meter": { $gt: 99 } },
                               { "metacritic": { $gt: 95 } } ] }).count();

// $and is used when we need to specify multiple criteria on the same field							   
db.movieDetails.find({ $and : [ { "metacritic": { $ne: null } },
                               { "metacritic": { $exists: true } } ] }).count();
							   
##### Regex operator

// Return all the documents which have awards.text field started by the word "Won ". "\s" means "space".
db.movieDetails.find({ "awards.text": { $regex: /^Won\s.*/ } }).pretty()

##### Array operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-array/

// Return all documents which have comedy, crime and drame in their genres field.
db.movieDetails.find({ genres: { $all: ["Comedy", "Crime", "Drama"] } }).pretty()	

// This is entire different from the example using $elemMatch because it won't try by each element contained in the array.
// Actually each field will be evaluated individually
db.movieDetails.find({ boxOffice: { country: "UK", revenue: { $gt: 15 } } })

db.movieDetails.find({ boxOffice: {$elemMatch: { country: "UK", revenue: { $gt: 15 } } } })

##### Updating documents

// Update any document that has imbd.id equal to detail.imdb.id
// Replace the document with detail
// If this filter doesn't match any document in my collection, so I want to go ahead and create a new one, with a new _id
db.movieDetails.updateOne(
	{ "imbd.id" : detail.imdb.id },
	{ $set : detail },
	{ upsert: true }
)

##### Homework 2.1

mvn compile exec:java -Dexec.mainClass=course.homework.MongoDBSparkFreemarkerStyle

##### Homework 2.2

mongoimport -d students -c grades < grades.json
use students
db.grades.count() // You should get 800.
// The student_id with the highest average score
db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
// All exam scores greater than or equal to 65, and sort those scores from lowest to highest.
db.grades.find({ score: { $gte: 65 } }).sort({ 'score': 1 });

##### Homework 2.3

// Sort student by its identity and limit the query to 12
db.grades.find().sort({'student_id' : 1}).limit(12);

##### Homework 2.3

// Remove the grade of type "homework" with the lowest score for each student from the dataset in the handout. 
// Since each document is one grade, it should remove one document per student. Sample:
/*
> db.grades.find({"student_id" : 0})
{ "_id" : ObjectId("50906d7fa3c412bb040eb577"), "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb579"), "student_id" : 0, "type" : "homework", "score" : 14.8504576811645 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb578"), "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb57a"), "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
*/

db.grades.aggregate(
	{
		"$match" : { "type" : "homework" }
	},
	{
		'$group': {
		'_id' : { student_id : "$student_id", type : "$type" },
		'min' : { '$min' : '$score' }
		}
	}, 
	{'$sort':{'_id':-1}}, 
	{'$limit':1});

// The result should be 600. Now let us find the student who holds the 101st best grade across all grades:
db.grades.find().sort( { 'score' : -1 } ).skip( 100 ).limit( 1 )	
// Now let us sort the students by student_id , and score, while also displaying the type to then see what the top five docs are:
db.grades.find( { }, { 'student_id' : 1, 'type' : 1, 'score' : 1, '_id' : 0 } ).sort( { 'student_id' : 1, 'score' : 1 } ).limit( 5 )
// The identity of the student with the highest average in the class
db.grades.aggregate( { '$group' : { '_id' : '$student_id', 'average' : { $avg : '$score' } } }, { '$sort' : { 'average' : -1 } }, { '$limit' : 1 } )
	
	
	