########################################
########## HELPFUL COMMANDS
########################################

show dbs                     	show database names
show collections             	show collections in current database
show users                   	show users in current database
db.getName();					Get current database name
use <db_name>					Set current database
db.dropDatabase();				Delete/drop current database
show collections				Show the collections contained in the current database

mvn clean compile exec:java -Dexec.mainClass=com.mongdb.App

> docker run -it -p 27017:27017 --name myMongo -d mongo
> docker exec -it myMongo mongo

########################################
########## WEEK 2 - CRUD

##### Creating documents

mongorestore dump
insertOne();
insertMany();
UPDATE COMMANDS is known as "upserts".

##### The _id Field

All collections have a unique primary index on the _id field by default.

			Date    MAC		PID		Counter
ObjectId: _ _ _ _ | _ _ _ | _ _ | _ _ _
12-Byte Hex String

Date - Current time stamp
MAC - The MAC address for the machine on which the MongoDB server is running.
PID - Process ID.
Counter - A standard counter to make sure that the ObjectId is indeed unique.

Note that the "Date" label that refers to the first four bytes does in fact reference a UTC datetime with a precision of seconds (not days). When talking about BSON, this is distinct from a timestamp, which is a special internal data type used in MongoDB replication and sharding.

##### Reading documents

db.movieDetails.find({ rated: "PG-13" }).pretty();
db.movieDetails.find({ rated: "PG-13" }).count();
db.movieDetails.find({ rated: "PG-13", year: 2009 }).count();
db.movieDetails.find({ "tomato.meter": 100 }).count();
db.movieDetails.find({ "tomato.meter": 99 }).pretty();

// For this particular case the order of the elements matters
// So the writers array must have only two elements following the order which each one was inserted
db.movieDetails.find({ "writers": ["Ethan Coen", "Joel Coen"] }).count();

// In this very case it will match all documents which have the actor "Jeff Bridges", thus this is not an exact match like the previous one
db.movieDetails.find({ "actors": "Jeff Bridges" }).pretty();

// All documents which have "Jeff Bridges" as the first element in actors array
db.movieDetails.find({ "actors.0": "Jeff Bridges" }).pretty();

// The find method returns a cursor. If you do the command below without assigning a variable to it, the cursor will automatically iterate up to 20 times.
db.movieDetails.find({ rated: "PG" }).pretty();

// Cursors

var c = db.movieDetails.find();
var doc = function() { return c.hasNext() ? c.next() : null; }
c.objsLeftInBatch(); // 101 documents in the initial batch
doc() // to iterate using the cursor
c.objsLeftInBatch(); // if will do the command again it will return 100 documents

// Projectinos

// It will include only the attribute title and exclude _id
db.movieDetails.find({ rated: "PG" }, { title: 1, _id: 0 } ).pretty();

// It will include all fields except for the ones explicity excluded below
db.movieDetails.find( { rated: "PG" }, { writers: 0, actors: 0, _id: 0 } ).pretty();

##### Comparison operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-comparison/

// All movies that have a runtime greater than 90
db.movieDetails.find({ runtime: { $gt: 90 } }).pretty();
db.movieDetails.find({ runtime: { $gt: 90 } }).count();
db.movieDetails.find({ runtime: { $gt: 90 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
// Greater than or equal to 90 and less than or equal to 120. It means: (runtime >= 90 && runtime <= 120)
db.movieDetails.find({ runtime: { $gte: 90, $lte: 120 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ "tomato.meter": { $gte: 95 }, runtime: { $gt: 180 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ rated: { $ne: "UNRATED" } }, { title: 1, runtime: 1, _id: 0 }).count();
// Return all the documents where the value of rated is G or PG
db.movieDetails.find({ rated: { $in: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();
// The reverse statement of the prepostion above
db.movieDetails.find({ rated: { $nin: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();

##### Element operators

// It verifies if there are documents which have tomate.meter field
db.movieDetails.find({ "tomato.meter": { $exists: true } }).count();

db.moviesScratch.find({ _id: { $type: "string" } }).pretty();
// We can count how many documents are stored with _id as String and so on
db.moviesScratch.find({ _id: { $type: "string" } }).count();
db.moviesScratch.find({ _id: { $type: "objectId" } }).pretty();

##### Logical operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-logical/

// $or takes an array as an argument
db.movieDetails.find({ $or : [ { "tomato.meter": { $gt: 99 } },
                               { "metacritic": { $gt: 95 } } ] }).count();

// $and is used when we need to specify multiple criteria on the same field							   
db.movieDetails.find({ $and : [ { "metacritic": { $ne: null } },
                               { "metacritic": { $exists: true } } ] }).count();
							   
##### Regex operator

// Return all the documents which have awards.text field started by the word "Won ". "\s" means "space".
db.movieDetails.find({ "awards.text": { $regex: /^Won\s.*/ } }).pretty()

##### Array operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-array/

// Return all documents which have comedy, crime and drame in their genres field.
db.movieDetails.find({ genres: { $all: ["Comedy", "Crime", "Drama"] } }).pretty()	

// This is entire different from the example using $elemMatch because it won't try by each element contained in the array.
// Actually each field will be evaluated individually
db.movieDetails.find({ boxOffice: { country: "UK", revenue: { $gt: 15 } } })

db.movieDetails.find({ boxOffice: {$elemMatch: { country: "UK", revenue: { $gt: 15 } } } })

##### Updating documents

// Update any document that has imbd.id equal to detail.imdb.id
// Replace the document with detail
// If this filter doesn't match any document in my collection, so I want to go ahead and create a new one, with a new _id
db.movieDetails.updateOne(
	{ "imbd.id" : detail.imdb.id },
	{ $set : detail },
	{ upsert: true }
)

##### Homework 2.1

mvn compile exec:java -Dexec.mainClass=course.homework.MongoDBSparkFreemarkerStyle

##### Homework 2.2

mongoimport -d students -c grades < grades.json
use students
db.grades.count() // You should get 800.
// The student_id with the highest average score
db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
// All exam scores greater than or equal to 65, and sort those scores from lowest to highest.
db.grades.find({ score: { $gte: 65 } }).sort({ 'score': 1 });

##### Homework 2.3

// Sort student by its identity and limit the query to 12
db.grades.find().sort({'student_id' : 1}).limit(12);

// Remove the grade of type "homework" with the lowest score for each student from the dataset in the handout. 
// Since each document is one grade, it should remove one document per student. Sample:
/*
> db.grades.find({"student_id" : 0})
{ "_id" : ObjectId("50906d7fa3c412bb040eb577"), "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb579"), "student_id" : 0, "type" : "homework", "score" : 14.8504576811645 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb578"), "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb57a"), "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
*/

db.grades.aggregate(
	{
		"$match" : { "type" : "homework" }
	},
	{
		'$group': {
		'_id' : { student_id : "$student_id", type : "$type" },
		'min' : { '$min' : '$score' }
		}
	}, 
	{'$sort':{'_id':-1}}, 
	{'$limit':1});

// The result should be 600. Now let us find the student who holds the 101st best grade across all grades:
db.grades.find().sort( { 'score' : -1 } ).skip( 100 ).limit( 1 )	
// Now let us sort the students by student_id , and score, while also displaying the type to then see what the top five docs are:
db.grades.find( { }, { 'student_id' : 1, 'type' : 1, 'score' : 1, '_id' : 0 } ).sort( { 'student_id' : 1, 'score' : 1 } ).limit( 5 )
// The identity of the student with the highest average in the class
db.grades.aggregate( { '$group' : { '_id' : '$student_id', 'average' : { $avg : '$score' } } }, { '$sort' : { 'average' : -1 } }, { '$limit' : 1 } )
	
##### Homework 2.5

// Which of the choices below is the title of a movie from the year 2013 that is rated PG-13 and won no awards?

db.movieDetails.find({ "rated": "PG-13", "year": 2013, "awards.wins": 0})	

##### Homework 2.6

// Using the video.movieDetails collection, how many movies list "Sweden" second in the the list of countries.

db.movieDetails.find({ "countries.1": "Sweden" })	

########################################
########## WEEK 3 - SCHEMA DESIGN

// --------- Introduction

// https://en.wikipedia.org/wiki/Third_normal_form

// Application driven schema

MongoDB keys: 
	1 - Rich documents
	2 - Pre Join / Embed Data
	3 - No Mongo Joins - it doesn't support joins directly inside de kernel, you must do it inside de application
	4 - There are no constraints
	5 - Atomic operations - MongoDB doesn't support transactions, but it does support atomic operations within one document.
	6 - No declared schema

What's the single most important factor in designing your application schema within MongoDB?
A: Matching the data access patterns of your application

What's the single most important factor in designing your application schema within MongoDB?
A: Matching the data access patterns of your application

// --------- Living wihout transactions

Restructure to create a single document and then make good use of atomic operations
Implement transaction in software like MongoDB critical section
And at last tolerate a little bit of inconsistency

Which of the following operations operate atomically within a single document? Check all that apply.
Update, findAndModify, $addToSet(within an update) and $push within an update

// --------- One to one relations

Frequency of access
Size of the items
Atomicity of data

// --------- One to many relations	

One modest type of one to many is when you think about people vs city situation. It's complicated to make a good relationship with MongoDB, true linking is one way to resolve it.

// --------- One to few relations	

It's like one to many, but a lot easier with MongoDB. Blog post vs comments is a typical  situation.

// --------- Many to many relations

Samples situations are books vs authors and students vs teachers. As you can see they are not truly many to many but few to few, so you can linking or embedding, of course you must evaluate pretty well which one best suits you.

// --------- Multikeys indexes

> db.students.find()
{ "_id" : 0, "name" : "Andrew Erlichson", "teachers" : [ 0, 1 ] }
{ "_id" : 1, "name" : "Richard Kreuter", "teachers" : [ 0, 1, 3 ] }
{ "_id" : 2, "name" : "Eliot Horowitz", "teachers" : [ 1, 2, 3 ] }
{ "_id" : 3, "name" : "Mark Heinrich", "teachers" : [ 0, 3 ] }
> db.teachers.find()
{ "_id" : 0, "name" : "Mark Horowitz" }
{ "_id" : 1, "name" : "John Hennessy" }
{ "_id" : 2, "name" : "Bruce Wolley" }
{ "_id" : 3, "name" : "James Plummer" }
> db.students.ensureIndex({ 'teachers' : 1 })
// All the students who had Mark Horowitz and John Hennessy as professors
> db.students.find({ 'teachers' : { $all : [0,1] } )
{ "_id" : 0, "name" : "Andrew Erlichson", "teachers" : [ 0, 1 ] }
{ "_id" : 1, "name" : "Richard Kreuter", "teachers" : [ 0, 1, 3 ] }
// How do we know that used an index?
> db.students.find({ 'teachers' : { $all : [0,1] } ).explain()

// --------- Benefits of embedding

The main benefit of embedding data from two different collections and bringing it together into one collection is performance.

- Improved read performance
- One round trip to the DB

// --------- Representing trees

https://docs.mongodb.com/manual/tutorial/model-tree-structures-with-ancestors-array/

Given the following typical document for a e-commerce category hierarchy collection called categories.

{
  _id: 34,
  name: "Snorkeling",
  parent_id: 12,
  ancestors: [12, 35, 90]
}

Which query will find all descendants of the snorkeling category?

db.categories.find({ ancestors : 34 })

// --------- ODM introduction

https://mongodb.github.io/morphia/

ODM means Object Document Mapper.

##### Homework 3.1

// Write a program in the language of your choice that will remove the lowest homework score for each student. Since there is a single document for each student containing an array of scores, you will need to update the scores array and remove the homework.

// Remember, just remove a homework score. Don't remove a quiz or an exam!

// Hint/spoiler: With the new schema, this problem is a lot harder and that is sort of the point. One way is to find the lowest homework in code and then update the scores array with the low homework pruned.

use school
db.students.count() // should return 200
db.students.find( { _id : 137 } ).pretty()

{
	"_id" : 137,
	"name" : "Tamika Schildgen",
	"scores" : [
		{
			"type" : "exam",
			"score" : 4.433956226109692
		},
		{
			"type" : "quiz",
			"score" : 65.50313785402548
		},
		{
			"type" : "homework",
			"score" : 89.5950384993947
		},
		{
			"type" : "homework",
			"score" : 54.75994689226145
		}
	]
}

db.students.find( { _id : 19 } ).pretty()

{
	"_id" : 19,
	"name" : "Gisela Levin",
	"scores" : [
		{
			"type" : "exam",
			"score" : 44.51211101958831
		},
		{
			"type" : "quiz",
			"score" : 0.6578497966368002
		},
		{
			"type" : "homework",
			"score" : 93.36341655949683
		},
		{
			"type" : "homework",
			"score" : 49.43132782777443
		}
	]
}

// Annotations

> db.students.aggregate([ {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : 199, "name" : "Rae Kohout", "scores" : [ { "type" : "exam", "score" : 82.11742562118049 }, { "type" : "quiz", "score" : 49.61
295450928224 }, { "type" : "homework", "score" : 28.86823689842918 }, { "type" : "homework", "score" : 5.861613903793295 } ] }
{ "_id" : 198, "name" : "Timothy Harrod", "scores" : [ { "type" : "exam", "score" : 11.9075674046519 }, { "type" : "quiz", "score" : 20
.51879961777022 }, { "type" : "homework", "score" : 55.85952928204192 }, { "type" : "homework", "score" : 64.85650354990375 } ] }
{ "_id" : 197, "name" : "Tonisha Games", "scores" : [ { "type" : "exam", "score" : 38.51269589995049 }, { "type" : "quiz", "score" : 31
.16287577231703 }, { "type" : "homework", "score" : 79.15856355963004 }, { "type" : "homework", "score" : 56.17504143517339 } ] }
{ "_id" : 196, "name" : "Santiago Dollins", "scores" : [ { "type" : "exam", "score" : 52.04052571137036 }, { "type" : "quiz", "score" :
 33.63300076481705 }, { "type" : "homework", "score" : 4.629511012591447 }, { "type" : "homework", "score" : 78.79257377604428 } ] }
 
// https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/ 
 
> db.students.aggregate([ { $unwind: "$scores" }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "homework", "score" : 5.861613903793295 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "quiz", "score" : 49.61295450928224 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "homework", "score" : 28.86823689842918 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "exam", "score" : 82.11742562118049 } }

> db.students.aggregate([ { $unwind: "$scores" }, { $group: { '_id' : { _id : "$_id", type : "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':3} ]);
{ "_id" : { "_id" : 199, "type" : "quiz" }, "min" : 49.61295450928224 }
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 199, "type" : "exam" }, "min" : 82.11742562118049 }

> db.students.aggregate([ { $unwind: "$scores" }, { $group: { '_id' : { _id : "$_id", type : "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : { "_id" : 199, "type" : "quiz" }, "min" : 49.61295450928224 }
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 199, "type" : "exam" }, "min" : 82.11742562118049 }
{ "_id" : { "_id" : 198, "type" : "quiz" }, "min" : 20.51879961777022 }

> db.students.aggregate([ { $unwind: "$scores" }, { $match : { "scores.type" : "homework" } }, { $group: { '_id' : { _id : "$_id", type: "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 198, "type" : "homework" }, "min" : 55.85952928204192 }
{ "_id" : { "_id" : 197, "type" : "homework" }, "min" : 56.17504143517339 }
{ "_id" : { "_id" : 196, "type" : "homework" }, "min" : 4.629511012591447 }

db.students.aggregate([	
	{ $unwind: "$scores" },
	{ $match : { "scores.type" : "homework" } },
	{ $group: {
			'_id' : { _id : "$_id", type : "$scores.type" },
			'min' : { '$min' : '$scores.score' }
		}
	},	
	{'$sort':{'_id':-1}}, 
	{'$limit':1}
]);

https://docs.mongodb.com/manual/reference/operator/update/positional/#update-embedded-documents-using-multiple-field-matches
https://docs.mongodb.com/manual/reference/operator/update/pull/#remove-items-from-an-array-of-documents

db.students.find({ "_id": 199 })

db.students.update(
	{ "_id": 199 },
	{ $pull: { scores: { type: "homework" , score: 5.861613903793295 } } },
	{ multi: true }
)

// To verify that you have completed this task correctly, provide the identity (in the form of their _id) of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document.

db.students.aggregate( [
  { '$unwind': '$scores' },
  {
    '$group':
    {
      '_id': '$_id',
      'average': { $avg: '$scores.score' }
    }
  },
  { '$sort': { 'average' : -1 } },
  { '$limit': 1 } ] )