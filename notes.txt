########################################
########## HELPFUL COMMANDS
########################################

show dbs                     	show database names
show collections             	show collections in current database
show users                   	show users in current database
db.getName();					Get current database name
use <db_name>					Set current database
db.dropDatabase();				Delete/drop current database
show collections				Show the collections contained in the current database

mvn clean compile exec:java -Dexec.mainClass=com.mongdb.App

> docker run -it -p 27017:27017 --name myMongo -d mongo
> docker exec -it myMongo mongo

########################################
########## WEEK 2 - CRUD

##### Creating documents

mongorestore dump
insertOne();
insertMany();
UPDATE COMMANDS is known as "upserts".

##### The _id Field

All collections have a unique primary index on the _id field by default.

			Date    MAC		PID		Counter
ObjectId: _ _ _ _ | _ _ _ | _ _ | _ _ _
12-Byte Hex String

Date - Current time stamp
MAC - The MAC address for the machine on which the MongoDB server is running.
PID - Process ID.
Counter - A standard counter to make sure that the ObjectId is indeed unique.

Note that the "Date" label that refers to the first four bytes does in fact reference a UTC datetime with a precision of seconds (not days). When talking about BSON, this is distinct from a timestamp, which is a special internal data type used in MongoDB replication and sharding.

##### Reading documents

db.movieDetails.find({ rated: "PG-13" }).pretty();
db.movieDetails.find({ rated: "PG-13" }).count();
db.movieDetails.find({ rated: "PG-13", year: 2009 }).count();
db.movieDetails.find({ "tomato.meter": 100 }).count();
db.movieDetails.find({ "tomato.meter": 99 }).pretty();

// For this particular case the order of the elements matters
// So the writers array must have only two elements following the order which each one was inserted
db.movieDetails.find({ "writers": ["Ethan Coen", "Joel Coen"] }).count();

// In this very case it will match all documents which have the actor "Jeff Bridges", thus this is not an exact match like the previous one
db.movieDetails.find({ "actors": "Jeff Bridges" }).pretty();

// All documents which have "Jeff Bridges" as the first element in actors array
db.movieDetails.find({ "actors.0": "Jeff Bridges" }).pretty();

// The find method returns a cursor. If you do the command below without assigning a variable to it, the cursor will automatically iterate up to 20 times.
db.movieDetails.find({ rated: "PG" }).pretty();

// Cursors

var c = db.movieDetails.find();
var doc = function() { return c.hasNext() ? c.next() : null; }
c.objsLeftInBatch(); // 101 documents in the initial batch
doc() // to iterate using the cursor
c.objsLeftInBatch(); // if will do the command again it will return 100 documents

// Projectinos

// It will include only the attribute title and exclude _id
db.movieDetails.find({ rated: "PG" }, { title: 1, _id: 0 } ).pretty();

// It will include all fields except for the ones explicity excluded below
db.movieDetails.find( { rated: "PG" }, { writers: 0, actors: 0, _id: 0 } ).pretty();

##### Comparison operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-comparison/

// All movies that have a runtime greater than 90
db.movieDetails.find({ runtime: { $gt: 90 } }).pretty();
db.movieDetails.find({ runtime: { $gt: 90 } }).count();
db.movieDetails.find({ runtime: { $gt: 90 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
// Greater than or equal to 90 and less than or equal to 120. It means: (runtime >= 90 && runtime <= 120)
db.movieDetails.find({ runtime: { $gte: 90, $lte: 120 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ "tomato.meter": { $gte: 95 }, runtime: { $gt: 180 } }, { title: 1, runtime: 1, _id: 0 }).pretty();
db.movieDetails.find({ rated: { $ne: "UNRATED" } }, { title: 1, runtime: 1, _id: 0 }).count();
// Return all the documents where the value of rated is G or PG
db.movieDetails.find({ rated: { $in: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();
// The reverse statement of the prepostion above
db.movieDetails.find({ rated: { $nin: ["G", "PG"] } }, { title: 1, runtime: 1, _id: 0 }).count();

##### Element operators

// It verifies if there are documents which have tomate.meter field
db.movieDetails.find({ "tomato.meter": { $exists: true } }).count();

db.moviesScratch.find({ _id: { $type: "string" } }).pretty();
// We can count how many documents are stored with _id as String and so on
db.moviesScratch.find({ _id: { $type: "string" } }).count();
db.moviesScratch.find({ _id: { $type: "objectId" } }).pretty();

##### Logical operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-logical/

// $or takes an array as an argument
db.movieDetails.find({ $or : [ { "tomato.meter": { $gt: 99 } },
                               { "metacritic": { $gt: 95 } } ] }).count();

// $and is used when we need to specify multiple criteria on the same field							   
db.movieDetails.find({ $and : [ { "metacritic": { $ne: null } },
                               { "metacritic": { $exists: true } } ] }).count();
							   
##### Regex operator

// Return all the documents which have awards.text field started by the word "Won ". "\s" means "space".
db.movieDetails.find({ "awards.text": { $regex: /^Won\s.*/ } }).pretty()

##### Array operators

// More details at https://docs.mongodb.com/manual/reference/operator/query-array/

// Return all documents which have comedy, crime and drame in their genres field.
db.movieDetails.find({ genres: { $all: ["Comedy", "Crime", "Drama"] } }).pretty()	

// This is entire different from the example using $elemMatch because it won't try by each element contained in the array.
// Actually each field will be evaluated individually
db.movieDetails.find({ boxOffice: { country: "UK", revenue: { $gt: 15 } } })

db.movieDetails.find({ boxOffice: {$elemMatch: { country: "UK", revenue: { $gt: 15 } } } })

##### Updating documents

// Update any document that has imbd.id equal to detail.imdb.id
// Replace the document with detail
// If this filter doesn't match any document in my collection, so I want to go ahead and create a new one, with a new _id
db.movieDetails.updateOne(
	{ "imbd.id" : detail.imdb.id },
	{ $set : detail },
	{ upsert: true }
)

##### Homework 2.1

mvn compile exec:java -Dexec.mainClass=course.homework.MongoDBSparkFreemarkerStyle

##### Homework 2.2

mongoimport -d students -c grades < grades.json
use students
db.grades.count() // You should get 800.
// The student_id with the highest average score
db.grades.aggregate({'$group':{'_id':'$student_id', 'average':{$avg:'$score'}}}, {'$sort':{'average':-1}}, {'$limit':1})
// All exam scores greater than or equal to 65, and sort those scores from lowest to highest.
db.grades.find({ score: { $gte: 65 } }).sort({ 'score': 1 });

##### Homework 2.3

// Sort student by its identity and limit the query to 12
db.grades.find().sort({'student_id' : 1}).limit(12);

// Remove the grade of type "homework" with the lowest score for each student from the dataset in the handout. 
// Since each document is one grade, it should remove one document per student. Sample:
/*
> db.grades.find({"student_id" : 0})
{ "_id" : ObjectId("50906d7fa3c412bb040eb577"), "student_id" : 0, "type" : "exam", "score" : 54.6535436362647 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb579"), "student_id" : 0, "type" : "homework", "score" : 14.8504576811645 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb578"), "student_id" : 0, "type" : "quiz", "score" : 31.95004496742112 }
{ "_id" : ObjectId("50906d7fa3c412bb040eb57a"), "student_id" : 0, "type" : "homework", "score" : 63.98402553675503 }
*/

db.grades.aggregate(
	{
		"$match" : { "type" : "homework" }
	},
	{
		'$group': {
		'_id' : { student_id : "$student_id", type : "$type" },
		'min' : { '$min' : '$score' }
		}
	}, 
	{'$sort':{'_id':-1}}, 
	{'$limit':1});

// The result should be 600. Now let us find the student who holds the 101st best grade across all grades:
db.grades.find().sort( { 'score' : -1 } ).skip( 100 ).limit( 1 )	
// Now let us sort the students by student_id , and score, while also displaying the type to then see what the top five docs are:
db.grades.find( { }, { 'student_id' : 1, 'type' : 1, 'score' : 1, '_id' : 0 } ).sort( { 'student_id' : 1, 'score' : 1 } ).limit( 5 )
// The identity of the student with the highest average in the class
db.grades.aggregate( { '$group' : { '_id' : '$student_id', 'average' : { $avg : '$score' } } }, { '$sort' : { 'average' : -1 } }, { '$limit' : 1 } )
	
##### Homework 2.5

// Which of the choices below is the title of a movie from the year 2013 that is rated PG-13 and won no awards?

db.movieDetails.find({ "rated": "PG-13", "year": 2013, "awards.wins": 0})	

##### Homework 2.6

// Using the video.movieDetails collection, how many movies list "Sweden" second in the the list of countries.

db.movieDetails.find({ "countries.1": "Sweden" })	

########################################
########## WEEK 3 - SCHEMA DESIGN

// --------- Introduction

// https://en.wikipedia.org/wiki/Third_normal_form

// Application driven schema

MongoDB keys: 
	1 - Rich documents
	2 - Pre Join / Embed Data
	3 - No Mongo Joins - it doesn't support joins directly inside de kernel, you must do it inside de application
	4 - There are no constraints
	5 - Atomic operations - MongoDB doesn't support transactions, but it does support atomic operations within one document.
	6 - No declared schema

What's the single most important factor in designing your application schema within MongoDB?
A: Matching the data access patterns of your application

What's the single most important factor in designing your application schema within MongoDB?
A: Matching the data access patterns of your application

// --------- Living wihout transactions

Restructure to create a single document and then make good use of atomic operations
Implement transaction in software like MongoDB critical section
And at last tolerate a little bit of inconsistency

Which of the following operations operate atomically within a single document? Check all that apply.
Update, findAndModify, $addToSet(within an update) and $push within an update

// --------- One to one relations

Frequency of access
Size of the items
Atomicity of data

// --------- One to many relations	

One modest type of one to many is when you think about people vs city situation. It's complicated to make a good relationship with MongoDB, true linking is one way to resolve it.

// --------- One to few relations	

It's like one to many, but a lot easier with MongoDB. Blog post vs comments is a typical  situation.

// --------- Many to many relations

Samples situations are books vs authors and students vs teachers. As you can see they are not truly many to many but few to few, so you can linking or embedding, of course you must evaluate pretty well which one best suits you.

// --------- Multikeys indexes

> db.students.find()
{ "_id" : 0, "name" : "Andrew Erlichson", "teachers" : [ 0, 1 ] }
{ "_id" : 1, "name" : "Richard Kreuter", "teachers" : [ 0, 1, 3 ] }
{ "_id" : 2, "name" : "Eliot Horowitz", "teachers" : [ 1, 2, 3 ] }
{ "_id" : 3, "name" : "Mark Heinrich", "teachers" : [ 0, 3 ] }
> db.teachers.find()
{ "_id" : 0, "name" : "Mark Horowitz" }
{ "_id" : 1, "name" : "John Hennessy" }
{ "_id" : 2, "name" : "Bruce Wolley" }
{ "_id" : 3, "name" : "James Plummer" }
> db.students.ensureIndex({ 'teachers' : 1 })
// All the students who had Mark Horowitz and John Hennessy as professors
> db.students.find({ 'teachers' : { $all : [0,1] } )
{ "_id" : 0, "name" : "Andrew Erlichson", "teachers" : [ 0, 1 ] }
{ "_id" : 1, "name" : "Richard Kreuter", "teachers" : [ 0, 1, 3 ] }
// How do we know that used an index?
> db.students.find({ 'teachers' : { $all : [0,1] } ).explain()

// --------- Benefits of embedding

The main benefit of embedding data from two different collections and bringing it together into one collection is performance.

- Improved read performance
- One round trip to the DB

// --------- Representing trees

https://docs.mongodb.com/manual/tutorial/model-tree-structures-with-ancestors-array/

Given the following typical document for a e-commerce category hierarchy collection called categories.

{
  _id: 34,
  name: "Snorkeling",
  parent_id: 12,
  ancestors: [12, 35, 90]
}

Which query will find all descendants of the snorkeling category?

db.categories.find({ ancestors : 34 })

// --------- ODM introduction

https://mongodb.github.io/morphia/

ODM means Object Document Mapper.

##### Homework 3.1

// Write a program in the language of your choice that will remove the lowest homework score for each student. Since there is a single document for each student containing an array of scores, you will need to update the scores array and remove the homework.

// Remember, just remove a homework score. Don't remove a quiz or an exam!

// Hint/spoiler: With the new schema, this problem is a lot harder and that is sort of the point. One way is to find the lowest homework in code and then update the scores array with the low homework pruned.

use school
db.students.count() // should return 200
db.students.find( { _id : 137 } ).pretty()

{
	"_id" : 137,
	"name" : "Tamika Schildgen",
	"scores" : [
		{
			"type" : "exam",
			"score" : 4.433956226109692
		},
		{
			"type" : "quiz",
			"score" : 65.50313785402548
		},
		{
			"type" : "homework",
			"score" : 89.5950384993947
		},
		{
			"type" : "homework",
			"score" : 54.75994689226145
		}
	]
}

db.students.find( { _id : 19 } ).pretty()

{
	"_id" : 19,
	"name" : "Gisela Levin",
	"scores" : [
		{
			"type" : "exam",
			"score" : 44.51211101958831
		},
		{
			"type" : "quiz",
			"score" : 0.6578497966368002
		},
		{
			"type" : "homework",
			"score" : 93.36341655949683
		},
		{
			"type" : "homework",
			"score" : 49.43132782777443
		}
	]
}

// Annotations

> db.students.aggregate([ {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : 199, "name" : "Rae Kohout", "scores" : [ { "type" : "exam", "score" : 82.11742562118049 }, { "type" : "quiz", "score" : 49.61
295450928224 }, { "type" : "homework", "score" : 28.86823689842918 }, { "type" : "homework", "score" : 5.861613903793295 } ] }
{ "_id" : 198, "name" : "Timothy Harrod", "scores" : [ { "type" : "exam", "score" : 11.9075674046519 }, { "type" : "quiz", "score" : 20
.51879961777022 }, { "type" : "homework", "score" : 55.85952928204192 }, { "type" : "homework", "score" : 64.85650354990375 } ] }
{ "_id" : 197, "name" : "Tonisha Games", "scores" : [ { "type" : "exam", "score" : 38.51269589995049 }, { "type" : "quiz", "score" : 31
.16287577231703 }, { "type" : "homework", "score" : 79.15856355963004 }, { "type" : "homework", "score" : 56.17504143517339 } ] }
{ "_id" : 196, "name" : "Santiago Dollins", "scores" : [ { "type" : "exam", "score" : 52.04052571137036 }, { "type" : "quiz", "score" :
 33.63300076481705 }, { "type" : "homework", "score" : 4.629511012591447 }, { "type" : "homework", "score" : 78.79257377604428 } ] }
 
// https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/ 
 
> db.students.aggregate([ { $unwind: "$scores" }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "homework", "score" : 5.861613903793295 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "quiz", "score" : 49.61295450928224 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "homework", "score" : 28.86823689842918 } }
{ "_id" : 199, "name" : "Rae Kohout", "scores" : { "type" : "exam", "score" : 82.11742562118049 } }

> db.students.aggregate([ { $unwind: "$scores" }, { $group: { '_id' : { _id : "$_id", type : "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':3} ]);
{ "_id" : { "_id" : 199, "type" : "quiz" }, "min" : 49.61295450928224 }
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 199, "type" : "exam" }, "min" : 82.11742562118049 }

> db.students.aggregate([ { $unwind: "$scores" }, { $group: { '_id' : { _id : "$_id", type : "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : { "_id" : 199, "type" : "quiz" }, "min" : 49.61295450928224 }
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 199, "type" : "exam" }, "min" : 82.11742562118049 }
{ "_id" : { "_id" : 198, "type" : "quiz" }, "min" : 20.51879961777022 }

> db.students.aggregate([ { $unwind: "$scores" }, { $match : { "scores.type" : "homework" } }, { $group: { '_id' : { _id : "$_id", type: "$scores.type" }, 'min' : { '$min' : '$scores.score' } } }, {'$sort':{'_id':-1}},  {'$limit':4} ]);
{ "_id" : { "_id" : 199, "type" : "homework" }, "min" : 5.861613903793295 }
{ "_id" : { "_id" : 198, "type" : "homework" }, "min" : 55.85952928204192 }
{ "_id" : { "_id" : 197, "type" : "homework" }, "min" : 56.17504143517339 }
{ "_id" : { "_id" : 196, "type" : "homework" }, "min" : 4.629511012591447 }

db.students.aggregate([	
	{ $unwind: "$scores" },
	{ $match : { "scores.type" : "homework" } },
	{ $group: {
			'_id' : { _id : "$_id", type : "$scores.type" },
			'min' : { '$min' : '$scores.score' }
		}
	},	
	{'$sort':{'_id':-1}}, 
	{'$limit':1}
]);

https://docs.mongodb.com/manual/reference/operator/update/positional/#update-embedded-documents-using-multiple-field-matches
https://docs.mongodb.com/manual/reference/operator/update/pull/#remove-items-from-an-array-of-documents

db.students.find({ "_id": 199 })

db.students.update(
	{ "_id": 199 },
	{ $pull: { scores: { type: "homework" , score: 5.861613903793295 } } },
	{ multi: true }
)

// To verify that you have completed this task correctly, provide the identity (in the form of their _id) of the student with the highest average in the class with following query that uses the aggregation framework. The answer will appear in the _id field of the resulting document.

db.students.aggregate( [
  { '$unwind': '$scores' },
  {
    '$group':
    {
      '_id': '$_id',
      'average': { $avg: '$scores.score' }
    }
  },
  { '$sort': { 'average' : -1 } },
  { '$limit': 1 } ] )
  
########################################
########## WEEK 4 - PERFORMANCE  

// --------- Storage Engines: Introduction

https://docs.mongodb.com/manual/core/storage-engines/

Main ways of performance:
	- Indexing
	- Sharding - Distributing database queries across multiple servers
	
Storage engine: It is located between MongoDB itself and for example a type of persistence storage like hard disk. It can use memory to storage data before send it to disk. If we compare to something real it's like a motor engine in your car, you can switch it for another when you like it to match some sort of requirement. MongoDB ships with two storage engines:
	- MMAP: It's the default for 3.0.
	- WiredTiger: It started to be the default on 3.2 --> https://docs.mongodb.com/manual/release-notes/3.2/#wiredtiger-as-default

The storage engine directly determines which of the following?
A: The data file format; Format of indexes.

// --------- Storage Engines: MMAPv1

1 - Collection level locking
2 - In place updates

http://docs.mongodb.org/manual/core/storage/?&_ga=2.176324003.721559069.1498430831-1068873678.1493258930#power-of-2-allocation

> man mmap // The description is "allocate memory, or map files or devices into memory"

Which of the following statements about the MMAPv1 storage engine are true? 
A: MMAPv1 automatically allocates power-of-two-sized documents when new documents are inserted; MMAPv1 is built on top of the mmap system call that maps files into memory.

Example that has record spaces allocated for as few as 4 bytes; in fact, the minimum record space in MongoDB 3.0 is 32 bytes.

// --------- Storage Engines: WiredTiger

1 - Document level concurrency
2 - Compressions of DATA and INDEXES
3 - No in place update

You can use this storage engine using -storageEngine. Sample:
> mongod -dbpath myCustomDir -storageEngine wiredTiger
> db.foo.insert({ name: 'Budega' })
> db.foo.stats(); // See the properties of the collection

Which of the following are features of the WiredTiger storage engine?
A: Document-level concurrency; Compression.

// --------- Indexes

https://docs.mongodb.com/manual/indexes/
https://en.wikipedia.org/wiki/B-tree -> A type of balanced search tree used frequently for indexing database tables

(a, b, c)
	a - OK
	ab - OK
	abc - OK
	b - NO
	c - NO
	And so on...
	
Writes: Indexes actually slows down your writes... Writes are much faster when there is no index
Read: But READS will be much faster!

Which optimization will typically have the greatest impact on the performance of a database?
A: Adding appropriate indexes on large collections so that only a small percentage of queries need to scan the collection.

// --------- Creating indexes

Use create_scores2.6f9f5645026a.js file to create 1.000.000 documents.
> db.students.find({ student_id: 5 }) // It will take a bunch of time
> db.students.explain().find({ student_id: 5 })
// On winningPlan you can see which type of scan was used during the query. For our case is COLLSCAN, it means that the collection was fully scanned (all the documents) in order to retrieve what was asked.
> db.students.findOne({ student_id: 5 }) // Faster than the find() option
> db.students.createIndex({ student_id: 1 }) // We want to create index on student_id ascending
> db.students.explain().find({ student_id: 5 })
> db.students.explain(true).find({ student_id: 5 }) // You can see how much documents were used in order to retrieve what was asked
> db.students.createIndex({ student_id: 1, class_id: -1 }) // student_id ascending and class_id descending

// --------- Discovering and Deleting Indexes

> db.students.getIndexes(); // There is default index which is on _id and you can't delete it
> db.students.dropIndexex({ student_id: 1 })

// --------- Multikey Indexes

Creating indexes on arrays is known as "multikey indexes".

{
	name : 'Budega',
	tags : [ 'tennis', 'programming', 'music' ],
	color : 'blue',
	location : ['SP', 'RJ']
}

Legal indexes: (tags), (tags, color)
Illegal indexes: (tags, location) -> Multikey indexes doesn't allow compound index to have two arrays

> db.foo.insert({ a : 1, b: 2 })
> db.foo.find()
> db.foo.createIndex({ a : 1, b : 1 })
> db.foo.explain().find({ a : 1, b : 1 }) // See indexName and isMultiKey fields
> db.foo.insert({ a : 3, b: [3,5,7] })
> db.foo.explain().find({ a : 1, b : 1 }) // See isMultiKey equals true now
> db.foo.explain().find({ a : 1, b : 5 })
> db.foo.getIndexes();
> db.foo.insert({ a : [3,4,6], b: [7,8,9] }) // It won't work: cannot index parallel arrays [b] [a]
> db.foo.insert({ a : [3,4,6], b: 8 }) // It works because it doesn't have parallel arrays

// --------- Dot notation and multikey

https://docs.mongodb.com/manual/reference/operator/query/elemMatch/

> db.students.createIndex({ 'scores.score' : 1 })
> db.students.explain().find({ 'scores.score' : { '$gt' : 99 } })
> db.students.find({ 'scores' : { '$elemMatch' : { type : 'exam', score : { '$gt' : 99.8 } } } }).count()
> db.students.explain().find({ 'scores' : { '$elemMatch' : { type : 'exam', score : { '$gt' : 99.8 } } } }) // You can see that the index search is made and then elemMatch ran in each document which were retrieved
> db.students.explain(true).find({ 'scores' : { '$elemMatch' : { type : 'exam', score : { '$gt' : 99.8 } } } }) // Just to make sure that the above statement is true... See docsExamined field.
> db.students.find({ 'scores.score' : { '$gt' : 99.8 } }).count() // It must matched docsExamined above
> db.students.find({ '$and' : [{ 'scores.type' : 'exam' }, { 'scores.score' : { '$gt' : 99.8 } }] }) // It does not work as elemMatch as you may get documents which you didn't want to
> db.students.explain().find({ '$and' : [{ 'scores.type' : 'exam' }, { 'scores.score' : { '$gt' : 99.8 } }] })

Suppose you have a collection called people in the database earth with documents of the following form:

{
    "_id" : ObjectId("551458821b87e1799edbebc4"),
    "name" : "Eliot Horowitz",
    "work_history" : [
        {
            "company" : "DoubleClick",
            "position" : "Software Engineer"
        },
        {
            "company" : "ShopWiki",
            "position" : "Founder & CTO"
        },
        {
            "company" : "MongoDB",
            "position" : "Founder & CTO"
        }
    ]
}

Type the command that you would issue in the Mongo shell to create an index on company, descending.

> db.people.createIndex({ 'work_history.company' : -1 })


// --------- Index Creation Options, Unique

https://docs.mongodb.com/v3.0/reference/method/db.collection.createIndex/#options

> db.stuff.drop();
> db.stuff.insert({ 'thing' : 'apple' })
> db.stuff.insert({ 'thing' : 'pear' })
> db.stuff.insert({ 'thing' : 'apple' })
> db.stuff.find()
> db.stuff.createIndex({ 'thing' : 1 })
> db.stuff.dropIndex({ 'thing' : 1 }, { unique: true }) // Error because there are two apples
> db.stuff.remove({ 'thing' : 'apple' }, { justOne: true })
> db.stuff.dropIndex({ 'thing' : 1 }, { unique: true }) // It works
> db.stuff.insert({ 'thing' : 'pear' }) // Duplicate key error
> db.stuff.getIndexes()

Please provide the mongo shell command to create a unique index on student_id, class_id, ascending for the collection students.
> db.students.createIndex({ student_id: 1, class_id: 1 }, { unique : true })

// --------- Sparse Indexes

https://docs.mongodb.com/manual/indexes/#sparse-indexes

It's a sort of index that can be used when the index key is missing from some of documents.
When you specify this options you tells MongoDB that it should not include in the index documents that are missing the key.

> db.employees.createIndex({ cell: 1}, { unique : true, sparse, true } })

One advantage of using sparse index is that it uses a lot less space than the common one.

What are the advantages of a sparse index?
A: The index will be smaller than it would if it were not sparse; You can gain greater flexibility with creating Unique indexes.

// --------- Index creation, background

http://docs.mongodb.org/manual/core/index-creation/?_ga=2.144413107.721559069.1498430831-1068873678.1493258930#index-creation-background

• Foreground
	1 - Fast
	2 - Blocks writers and readers in the database, it means... DO NOT DO IT IN PRODUCTION SYSTEMS!
• Background
	1 - Slower
	2 - DON'T block writers and readers in the database, it means... DO NOT DO IT IN PRODUCTION SYSTEMS!
	
> db.students.createIndex({ 'score.score' : 1 }, { background : true })

Which things are true about creating an index in the background in MongoDB.
A: Although the database server will continue to take requests, a background index creation still blocks the mongo shell that you are using to create the index; Creating an index in the background takes longer than creating it in the foreground.

Note that, in MongoDB 2.2, the answer that you can only make one background index per database would have been correct.

// --------- Explain

https://docs.mongodb.com/manual/reference/explain-results/

Explain is used to find out what the database is doing with your query, how it's executing it, what indexes it's using and how many documents it inspected when it actually runs the query. It didn't bring data to the client, only the "explain" information.

> var exp = db.foo.explain()
> exp.help()